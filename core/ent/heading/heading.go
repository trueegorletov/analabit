// Code generated by ent, DO NOT EDIT.

package heading

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the heading type in the database.
	Label = "heading"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldRegularCapacity holds the string denoting the regular_capacity field in the database.
	FieldRegularCapacity = "regular_capacity"
	// FieldTargetQuotaCapacity holds the string denoting the target_quota_capacity field in the database.
	FieldTargetQuotaCapacity = "target_quota_capacity"
	// FieldDedicatedQuotaCapacity holds the string denoting the dedicated_quota_capacity field in the database.
	FieldDedicatedQuotaCapacity = "dedicated_quota_capacity"
	// FieldSpecialQuotaCapacity holds the string denoting the special_quota_capacity field in the database.
	FieldSpecialQuotaCapacity = "special_quota_capacity"
	// FieldCode holds the string denoting the code field in the database.
	FieldCode = "code"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// EdgeVarsity holds the string denoting the varsity edge name in mutations.
	EdgeVarsity = "varsity"
	// EdgeApplications holds the string denoting the applications edge name in mutations.
	EdgeApplications = "applications"
	// EdgeCalculations holds the string denoting the calculations edge name in mutations.
	EdgeCalculations = "calculations"
	// EdgeDrainedResults holds the string denoting the drained_results edge name in mutations.
	EdgeDrainedResults = "drained_results"
	// Table holds the table name of the heading in the database.
	Table = "headings"
	// VarsityTable is the table that holds the varsity relation/edge.
	VarsityTable = "headings"
	// VarsityInverseTable is the table name for the Varsity entity.
	// It exists in this package in order to avoid circular dependency with the "varsity" package.
	VarsityInverseTable = "varsities"
	// VarsityColumn is the table column denoting the varsity relation/edge.
	VarsityColumn = "varsity_headings"
	// ApplicationsTable is the table that holds the applications relation/edge.
	ApplicationsTable = "applications"
	// ApplicationsInverseTable is the table name for the Application entity.
	// It exists in this package in order to avoid circular dependency with the "application" package.
	ApplicationsInverseTable = "applications"
	// ApplicationsColumn is the table column denoting the applications relation/edge.
	ApplicationsColumn = "heading_applications"
	// CalculationsTable is the table that holds the calculations relation/edge.
	CalculationsTable = "calculations"
	// CalculationsInverseTable is the table name for the Calculation entity.
	// It exists in this package in order to avoid circular dependency with the "calculation" package.
	CalculationsInverseTable = "calculations"
	// CalculationsColumn is the table column denoting the calculations relation/edge.
	CalculationsColumn = "heading_calculations"
	// DrainedResultsTable is the table that holds the drained_results relation/edge.
	DrainedResultsTable = "drained_results"
	// DrainedResultsInverseTable is the table name for the DrainedResult entity.
	// It exists in this package in order to avoid circular dependency with the "drainedresult" package.
	DrainedResultsInverseTable = "drained_results"
	// DrainedResultsColumn is the table column denoting the drained_results relation/edge.
	DrainedResultsColumn = "heading_drained_results"
)

// Columns holds all SQL columns for heading fields.
var Columns = []string{
	FieldID,
	FieldRegularCapacity,
	FieldTargetQuotaCapacity,
	FieldDedicatedQuotaCapacity,
	FieldSpecialQuotaCapacity,
	FieldCode,
	FieldName,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "headings"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"varsity_headings",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the Heading queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByRegularCapacity orders the results by the regular_capacity field.
func ByRegularCapacity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRegularCapacity, opts...).ToFunc()
}

// ByTargetQuotaCapacity orders the results by the target_quota_capacity field.
func ByTargetQuotaCapacity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTargetQuotaCapacity, opts...).ToFunc()
}

// ByDedicatedQuotaCapacity orders the results by the dedicated_quota_capacity field.
func ByDedicatedQuotaCapacity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDedicatedQuotaCapacity, opts...).ToFunc()
}

// BySpecialQuotaCapacity orders the results by the special_quota_capacity field.
func BySpecialQuotaCapacity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSpecialQuotaCapacity, opts...).ToFunc()
}

// ByCode orders the results by the code field.
func ByCode(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCode, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByVarsityField orders the results by varsity field.
func ByVarsityField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newVarsityStep(), sql.OrderByField(field, opts...))
	}
}

// ByApplicationsCount orders the results by applications count.
func ByApplicationsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newApplicationsStep(), opts...)
	}
}

// ByApplications orders the results by applications terms.
func ByApplications(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newApplicationsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCalculationsCount orders the results by calculations count.
func ByCalculationsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCalculationsStep(), opts...)
	}
}

// ByCalculations orders the results by calculations terms.
func ByCalculations(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCalculationsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByDrainedResultsCount orders the results by drained_results count.
func ByDrainedResultsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newDrainedResultsStep(), opts...)
	}
}

// ByDrainedResults orders the results by drained_results terms.
func ByDrainedResults(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDrainedResultsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newVarsityStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(VarsityInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, VarsityTable, VarsityColumn),
	)
}
func newApplicationsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ApplicationsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ApplicationsTable, ApplicationsColumn),
	)
}
func newCalculationsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CalculationsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, CalculationsTable, CalculationsColumn),
	)
}
func newDrainedResultsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DrainedResultsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, DrainedResultsTable, DrainedResultsColumn),
	)
}
